> 问题：使用正则表达式描述以下二进制字符串使得其对应的整数能够满足以下条件。  
> - 能被 2 整除  
> - 能被 3 整除  
> - 被 123 整除

## 1. 能被 2 整除

`(0|1)0`：以 0 结尾的二进制数都是可以被 2 整除的

## 2. 能被 3 整除

一个二进制数后面加一个 0 相当于该数乘以 2，一个二进制数后面加一个 1 相当于该数乘 2 加 1。设定三个状态，
分别叫做 0、1 和 2，它们表示当前的数除以 3 所得的余数。有以下的几种状态转移可能：
```java
0@0 => 0 : 表示当状态 0 最后一位数是 0 时, 转移到状态 0
0@1 => 1 : 表示当状态 0 最后一位数是 1 时, 转移到状态 1
1@0 => 2 : 表示当状态 1 最后一位数是 0 时, 转移到状态 2
1@1 => 0 : 表示当状态 1 最后一位数是 1 时, 转移到状态 0
2@0 => 1 : 表示当状态 2 最后一位数是 0 时, 转移到状态 1
2@1 => 2 : 表示当状态 2 最后一位数是 1 时, 转移到状态 2
```

给定一个二进制数，状态 0 是我们的初始状态；当经过一系列状态转换最后又回到状态 0，表示这个二进制数能够被 3 整除。
现在，假设给定一个二进制数`10010`，输入从左到右，它的状态转移如下：
1. 当前状态 0，尾数是 1，因此转移到状态 1。
2. 当前状态 1，尾数是 0，因此转移到状态 2。
3. 当前状态 2，尾数是 0，因此转移到状态 1。
4. 当前状态 1，尾数是 1，因此转移到状态 0。
5. 当前状态 0，尾数是 0，因此转移到状态 0。
6. 最终状态是 0，因此`10010`可以被 3 整除。

可以看到，上面的表述是一个**有限状态自动机（DFA）**，而`DFA`可以被转化成正则表达式。上面的这个自动机转化起来非常容易。
我们可以先试着用自然语言叙述一下。首先，除 0 以外，每个二进制数第一位必然为 1。到达状态 1 后，我们可以随意地、
任意多次地在状态 1 周围绕圈圈，最终回到状态 1。临近末尾，我们再读到一个 1 返回状态 0，这之后随便读多少个 0 都可以了。

现在问题分解为：我们又如何用正则表达式表述“从状态 1 出发随意地走最终回到状态 1”呢？在本例中，这是很好描述的：
它可以是字符串“1000..001”和“0111..110”的任意组合。其中 10...01 包含 11，011..110 包含 00。
在开头为 1 时：
 - 输入 10 后，再输入 0 达到状态 0，输入 1 回到状态 1
 - 输入 11 后，回到状态 1
 - 输入 00 后，回到状态 1
 - 输入 01 后，再输入 1 到达状态 2，输入 0 回到状态 1。

所以最终的答案是：`0+|0*1((10*1)|(01*0))*10*`

## 3. 被 123 整除

和第 2 节类似，只是这个状态机转换非常复杂，故几乎不能写出。